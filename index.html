<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>同時計測 脈波・パーソナルBPMアプリ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .chart-container {
            position: relative;
            height: 250px;
            width: 100%;
        }
        .tap-button:active {
            transform: scale(0.95);
            transition: transform 0.1s ease-in-out;
        }
        #message-box {
            transition: opacity 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200">

    <div class="container mx-auto p-4 md:p-8 max-w-6xl">
        
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-indigo-600 dark:text-indigo-400">同時計測アプリ</h1>
            <p class="mt-2 text-lg text-gray-600 dark:text-gray-400">脈波とタップによるパーソナルBPMを同時に計測します</p>
        </header>

        <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-xl p-6 md:p-8">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">

                <!-- ===== 左側: 操作パネルとタップ計測 ===== -->
                <div class="flex flex-col gap-6">
                    <div>
                        <label for="username" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">お名前</label>
                        <input type="text" id="username" class="w-full px-4 py-2 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-indigo-500" placeholder="名前を入力してください">
                        <p id="name-error" class="text-red-500 text-sm mt-2 hidden">お名前を入力してください。</p>
                    </div>

                    <div class="bg-gray-800 rounded-lg shadow-md p-2 flex flex-col items-center justify-center aspect-video w-full max-w-[240px] mx-auto relative">
                        <video id="video" autoplay playsinline class="w-full h-full rounded-md object-cover bg-gray-700"></video>
                        <canvas id="canvas" class="hidden"></canvas>
                        <div id="instruction" class="absolute inset-0 flex items-center justify-center text-center text-gray-400 p-2">
                            <p class="text-sm">指でカメラを覆ってください</p>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                        <button id="startButton" class="w-full flex items-center justify-center gap-2 bg-indigo-600 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:bg-indigo-700 transition disabled:bg-gray-400">スタート</button>
                        <button id="stopButton" class="w-full flex items-center justify-center gap-2 bg-red-600 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:bg-red-700 transition disabled:bg-gray-400" disabled>ストップ</button>
                        <button id="downloadButton" class="w-full flex items-center justify-center gap-2 bg-green-600 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:bg-green-700 transition disabled:bg-gray-400" disabled>CSV保存</button>
                    </div>
                    <div id="status" class="text-center p-2 bg-yellow-100 dark:bg-yellow-800 text-yellow-800 dark:text-yellow-100 rounded-lg hidden"></div>

                    <div class="flex-grow flex flex-col">
                        <h2 class="text-xl font-bold mb-2">タップ計測</h2>
                        <div id="tap-area" role="button" tabindex="0" class="tap-button bg-gradient-to-br from-purple-500 to-pink-600 text-white h-32 w-full rounded-2xl flex flex-col items-center justify-center cursor-pointer select-none">
                            <div class="text-center">
                                <span class="text-6xl font-bold" id="main-display">0</span>
                                <p class="mt-1 text-purple-200 text-lg">Taps</p>
                            </div>
                             <p class="mt-2 text-purple-200 text-sm">ここをタップ (100回で自動終了)</p>
                        </div>
                        <div class="mt-4 text-center">
                            <p class="text-gray-500 dark:text-gray-400 text-sm">タップ平均BPM</p>
                            <p id="average-bpm" class="text-2xl font-semibold">--</p>
                        </div>
                    </div>
                </div>

                <!-- ===== 右側: カメラ計測 ===== -->
                <div class="flex flex-col gap-6">
                    <h2 class="text-xl font-bold">脈波グラフと解析</h2>
                    
                    <div class="bg-gray-800 rounded-lg shadow-md p-4">
                        <h3 class="text-lg font-bold mb-2">リアルタイム脈波 (フィルター後)</h3>
                        <div class="chart-container">
                            <canvas id="waveformChart"></canvas>
                        </div>
                    </div>
                    
                    <div id="resultContainer" class="bg-gray-800 rounded-lg shadow-md p-6">
                        <h3 class="text-lg font-bold mb-4 border-b pb-2 border-gray-700">脈波 解析結果</h3>
                        <div class="grid grid-cols-3 gap-4 text-center">
                            <div>
                                <p class="text-sm text-gray-400">瞬間心拍数</p>
                                <p id="instant-bpm-value" class="text-2xl font-semibold text-cyan-400">-</p>
                            </div>
                            <div>
                                <p class="text-sm text-gray-400">平均心拍数</p>
                                <p id="avg-bpm-value" class="text-2xl font-semibold text-cyan-400">-</p>
                            </div>
                            <div>
                                <p class="text-sm text-gray-400">SDNN (最終)</p>
                                <p id="sdnn-value" class="text-2xl font-semibold text-cyan-400">-</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="message-box" class="fixed bottom-5 right-5 bg-red-600 text-white py-3 px-5 rounded-lg shadow-lg hidden opacity-0"></div>
    </div>

    <script>
    // --- グローバル状態 ---
    let appState = {
        isMeasuring: false,
        userName: '',
        startTime: 0, 
        csvData: [],
        pulseAnalysisInterval: null,
    };
    
    // --- DOM要素 ---
    const usernameInput = document.getElementById('username');
    const nameError = document.getElementById('name-error');
    const startButton = document.getElementById('startButton');
    const stopButton = document.getElementById('stopButton');
    const downloadButton = document.getElementById('downloadButton');
    const statusEl = document.getElementById('status');
    const messageBox = document.getElementById('message-box');

    // --- メイン操作ロジック ---
    startButton.addEventListener('click', () => {
        appState.userName = usernameInput.value.trim();
        if (!appState.userName) {
            nameError.classList.remove('hidden');
            return;
        }
        nameError.classList.add('hidden');
        initializeAll();
        appState.isMeasuring = true;
        updateMainUI(true);
        startPulseWave();
        startTapBpm();
    });

    stopButton.addEventListener('click', () => {
        if (!appState.isMeasuring) return;
        appState.isMeasuring = false;
        updateMainUI(false);
        stopPulseWave();
        stopTapBpm();
        generateCSVData(); // CSVデータを生成
    });
    
    downloadButton.addEventListener('click', () => {
        downloadCombinedCSV();
    });

    function initializeAll() {
        appState.startTime = 0;
        appState.csvData = [];
        if (appState.pulseAnalysisInterval) clearInterval(appState.pulseAnalysisInterval);
        initializePulseWave();
        initializeTapBpm();
    }

    function updateMainUI(isMeasuring) {
        startButton.disabled = isMeasuring;
        usernameInput.disabled = isMeasuring;
        stopButton.disabled = !isMeasuring;
        downloadButton.disabled = isMeasuring;
        
        if(isMeasuring) {
            showStatus('最初のタップで計測が開始されます...');
        } else {
            statusEl.classList.add('hidden');
            if (pulseState.rawTimestamps.length > 0 || tapState.taps.length > 0) {
                downloadButton.disabled = false;
            }
        }
    }

    function showStatus(message, isError = false) {
        statusEl.textContent = message;
        statusEl.classList.remove('hidden');
        statusEl.className = `text-center p-2 rounded-lg ${isError ? 'bg-red-100 dark:bg-red-800 text-red-800 dark:text-red-100' : 'bg-yellow-100 dark:bg-yellow-800 text-yellow-800 dark:text-yellow-100'}`;
    }
    
    // =================================================
    // ===== カメラ計測 (Pulse Wave) のロジック =====
    // =================================================
    const pulseElements = {
        video: document.getElementById('video'),
        canvas: document.getElementById('canvas'),
        instruction: document.getElementById('instruction'),
        resultContainer: document.getElementById('resultContainer'),
        instantBpmValue: document.getElementById('instant-bpm-value'),
        avgBpmValue: document.getElementById('avg-bpm-value'),
        sdnnValue: document.getElementById('sdnn-value'),
    };

    let pulseState = {};
    let waveformChart;

    function initializePulseWave() {
        pulseState = {
            stream: null, track: null, animationFrameId: null,
            rawBrightness: [], rawTimestamps: [],
            detectedPeaks: [], // Store {timestamp, value}
        };
        const waveformCtx = document.getElementById('waveformChart').getContext('2d');
        if (waveformChart) waveformChart.destroy();
        waveformChart = new Chart(waveformCtx, {
            type: 'line',
            data: { labels: [], datasets: [ { label: 'フィルター後の輝度変化', data: [], borderColor: 'rgb(79, 70, 229)', borderWidth: 2, pointRadius: 0, tension: 0.1 }, { type: 'scatter', label: '検出されたピーク', data: [], backgroundColor: 'rgba(255, 99, 132, 1)', radius: 5, } ] },
            options: { responsive: true, maintainAspectRatio: false, animation: false, scales: { x: { type: 'linear', display: true, title: { display: true, text: '時間 (s)' } }, y: { title: { display: true, text: '輝度' } } } }
        });
        pulseElements.resultContainer.classList.add('hidden');
        pulseElements.instantBpmValue.textContent = '-';
        pulseElements.avgBpmValue.textContent = '-';
        pulseElements.sdnnValue.textContent = '-';
    }

    async function startPulseWave() {
        try {
            pulseState.stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
            pulseElements.video.srcObject = pulseState.stream;
            await pulseElements.video.play();
            pulseElements.video.classList.remove('hidden');
            pulseElements.instruction.classList.add('hidden');
            try {
                pulseState.track = pulseState.stream.getVideoTracks()[0];
                if (pulseState.track.getCapabilities().torch) {
                    await pulseState.track.applyConstraints({ advanced: [{ torch: true }] });
                }
            } catch (torchError) { console.warn("トーチ機能の制御に失敗:", torchError); }
            pulseState.animationFrameId = requestAnimationFrame(measureLoop);
            appState.pulseAnalysisInterval = setInterval(analyzePulseChunk, 1000);
        } catch (err) {
            console.error("カメラへのアクセスに失敗:", err);
            showStatus('エラー: カメラにアクセスできません。', true);
        }
    }

    async function stopPulseWave() {
        if (pulseState.animationFrameId) cancelAnimationFrame(pulseState.animationFrameId);
        if (appState.pulseAnalysisInterval) clearInterval(appState.pulseAnalysisInterval);
        pulseState.animationFrameId = null;
        appState.pulseAnalysisInterval = null;

        if (pulseState.track && pulseState.track.readyState === 'live') {
            try {
                if (pulseState.track.getCapabilities().torch) {
                    await pulseState.track.applyConstraints({ advanced: [{ torch: false }] });
                }
            } catch (e) { console.warn("トーチの停止に失敗しました:", e); }
        }
        pulseState.stream?.getTracks().forEach(track => track.stop());
        pulseElements.video.srcObject = null;
        pulseElements.video.classList.add('hidden');
        pulseElements.instruction.classList.remove('hidden');
        
        // 最終解析はCSV生成時に行う
    }

    function measureLoop(currentTime) {
        if (!appState.isMeasuring) return;
        if (appState.startTime === 0) {
            pulseState.animationFrameId = requestAnimationFrame(measureLoop);
            return;
        }
        const { video, canvas } = pulseElements;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const avgBrightness = getAverageBrightness(frame.data);
        pulseState.rawTimestamps.push(performance.now());
        pulseState.rawBrightness.push(avgBrightness);
        pulseState.animationFrameId = requestAnimationFrame(measureLoop);
    }

    function updateWaveformChart(filteredData, peakData, timestamps) {
        const displayWindow = 10000;
        const now = performance.now();
        const visibleWaveData = [], visiblePeakData = [];
        const startIndex = Math.max(0, timestamps.length - filteredData.length);

        for(let i = 0; i < filteredData.length; i++) {
            const timestamp = timestamps[startIndex + i];
            if (now - timestamp <= displayWindow) {
                visibleWaveData.push({ x: ((timestamp - appState.startTime) / 1000), y: filteredData[i] });
            }
        }
        for(const peak of peakData) {
             if (now - peak.timestamp <= displayWindow) {
                visiblePeakData.push({ x: ((peak.timestamp - appState.startTime) / 1000), y: peak.value });
            }
        }
        waveformChart.data.datasets[0].data = visibleWaveData;
        waveformChart.data.datasets[1].data = visiblePeakData;
        waveformChart.update('none');
    }
    
    function analyzePulseChunk() {
        if (pulseState.rawBrightness.length < 256 || appState.startTime === 0) return;
        
        const signalChunk = pulseState.rawBrightness.map(v => 255 - v);
        const timeChunk = pulseState.rawTimestamps;
        const samplingRate = 1000 / ((timeChunk[timeChunk.length - 1] - timeChunk[0]) / (timeChunk.length - 1));

        const filteredSignal = applyBandpassFilter(signalChunk, samplingRate);
        const peaksInfo = findPeaksWithProminence(filteredSignal, timeChunk, samplingRate);
        
        updateWaveformChart(filteredSignal, peaksInfo, timeChunk);

        const allPeaks = [];
        peaksInfo.forEach(peak => {
            if (allPeaks.length === 0 || peak.timestamp > allPeaks[allPeaks.length - 1] + 200) {
                allPeaks.push(peak.timestamp);
            }
        });
        
        if (allPeaks.length >= 2) {
            const lastInterval = allPeaks[allPeaks.length - 1] - allPeaks[allPeaks.length - 2];
            const instantBpm = 60000 / lastInterval;
            
            const recentPeaks = allPeaks.slice(-11);
            let averageBpm = 0;
            if (recentPeaks.length > 1) {
                const totalInterval = recentPeaks[recentPeaks.length - 1] - recentPeaks[0];
                averageBpm = 60000 / (totalInterval / (recentPeaks.length - 1));
            }
            pulseElements.instantBpmValue.textContent = instantBpm.toFixed(1);
            pulseElements.avgBpmValue.textContent = averageBpm.toFixed(1);
            pulseElements.resultContainer.classList.remove('hidden');
        }
    }
    
    function getAverageBrightness(data) {
        let sum = 0;
        for (let i = 0; i < data.length; i += 4) sum += 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
        return sum / (data.length / 4);
    }

    // --- 信号処理ユーティリティ ---
    function applyBandpassFilter(signal, fs) {
        const lowCutoff = 40 / 60;
        const highCutoff = 300 / 60;
        const N = 1 << Math.floor(Math.log2(signal.length));
        const truncatedSignal = signal.slice(-N);
        const fftResult = fft(truncatedSignal.map(v => ({ re: v, im: 0 })));
        for (let i = 0; i < N; i++) {
            const freq = i * fs / N;
            const currentFreq = (i <= N / 2) ? freq : fs - freq;
            if (currentFreq < lowCutoff || currentFreq > highCutoff) {
                fftResult[i] = { re: 0, im: 0 };
            }
        }
        return ifft(fftResult).map(c => c.re);
    }

    function findPeaksWithProminence(data, timestamps, samplingRate) {
        if (data.length < 3) return [];
        
        const mean = data.reduce((a, b) => a + b) / data.length;
        const stdDev = Math.sqrt(data.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / data.length);
        
        const heightThreshold = mean + stdDev * 0.25;
        const prominenceThreshold = stdDev * 0.5;
        const minDistanceInIndices = samplingRate * 0.2;

        const localMaximaIndices = [];
        for (let i = 1; i < data.length - 1; i++) {
            if (data[i] > data[i - 1] && data[i] > data[i + 1]) {
                localMaximaIndices.push(i);
            }
        }

        const finalPeaks = [];
        let lastPeakIndex = -Infinity;

        for (const peakIndex of localMaximaIndices) {
            if (data[peakIndex] < heightThreshold) continue;

            let leftMin = data[peakIndex];
            for (let i = peakIndex - 1; i >= 0; i--) {
                if (data[i] < leftMin) leftMin = data[i];
                if (data[i] > data[peakIndex]) break;
            }
            let rightMin = data[peakIndex];
            for (let i = peakIndex + 1; i < data.length; i++) {
                if (data[i] < rightMin) rightMin = data[i];
                if (data[i] > data[peakIndex]) break;
            }
            
            const prominence = data[peakIndex] - Math.max(leftMin, rightMin);

            if (prominence > prominenceThreshold && peakIndex - lastPeakIndex > minDistanceInIndices) {
                 finalPeaks.push({ index: peakIndex, value: data[peakIndex], timestamp: timestamps[timestamps.length - data.length + peakIndex] });
                 lastPeakIndex = peakIndex;
            }
        }
        return finalPeaks;
    }

    function fft(data) {
        const N = data.length; if (N <= 1) return data;
        const ordered = [];
        for (let i = 0; i < N; i++) {
            let rev = 0;
            for (let j = 0; j < Math.log2(N); j++) rev |= ((i >> j) & 1) << (Math.log2(N) - 1 - j);
            ordered[i] = data[rev];
        }
        for (let len = 2; len <= N; len <<= 1) {
            const halfLen = len >> 1; const angle = -2 * Math.PI / len; const w_len = { re: Math.cos(angle), im: Math.sin(angle) };
            for (let i = 0; i < N; i += len) {
                let w = { re: 1, im: 0 };
                for (let j = 0; j < halfLen; j++) {
                    const u = ordered[i + j]; const v_re = ordered[i + j + halfLen].re * w.re - ordered[i + j + halfLen].im * w.im; const v_im = ordered[i + j + halfLen].re * w.im + ordered[i + j + halfLen].im * w.re;
                    ordered[i + j] = { re: u.re + v_re, im: u.im + v_im }; ordered[i + j + halfLen] = { re: u.re - v_re, im: u.im - v_im };
                    const next_w_re = w.re * w_len.re - w.im * w_len.im; const next_w_im = w.re * w_len.im + w.im * w_len.re; w = { re: next_w_re, im: next_w_im };
                }
            }
        }
        return ordered;
    }
    function ifft(data) {
        const N = data.length;
        const conjugated = data.map(c => ({ re: c.re, im: -c.im }));
        const result = fft(conjugated);
        return result.map(c => ({ re: c.re / N, im: -c.im / N }));
    }

    // ===========================================
    // ===== タップ計測 (BPM Tap) のロジック =====
    // ===========================================
    const tapElements = {
        mainDisplay: document.getElementById('main-display'),
        averageBpmDisplay: document.getElementById('average-bpm'),
        tapArea: document.getElementById('tap-area'),
    };
    let tapState = {};

    function initializeTapBpm() {
        tapState = { taps: [] };
        tapElements.mainDisplay.textContent = '0';
        tapElements.averageBpmDisplay.textContent = '--';
    }

    function startTapBpm() {
        initializeTapBpm();
        tapElements.tapArea.addEventListener('click', handleTap);
        tapElements.tapArea.addEventListener('keydown', handleTapKey);
    }

    function stopTapBpm() {
        tapElements.tapArea.removeEventListener('click', handleTap);
        tapElements.tapArea.removeEventListener('keydown', handleTapKey);
    }

    function handleTapKey(e) {
        if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); handleTap(); }
    }

    function handleTap() {
        if (!appState.isMeasuring) return;
        const now = performance.now();
        
        if (appState.startTime === 0) {
            appState.startTime = now;
            showStatus('計測中...');
        }

        tapState.taps.push(now);
        tapElements.mainDisplay.textContent = tapState.taps.length;
        
        if (tapState.taps.length >= 2) {
            const recentTaps = tapState.taps.slice(-11);
            if(recentTaps.length > 1) {
                const totalInterval = recentTaps[recentTaps.length-1] - recentTaps[0];
                const averageBpm = 60000 / (totalInterval / (recentTaps.length - 1));
                tapElements.averageBpmDisplay.textContent = Math.round(averageBpm);
            }
        }
        
        if (tapState.taps.length >= 100) {
            showStatus('100回のタップに到達しました。計測を終了します。');
            setTimeout(() => stopButton.click(), 500);
        }
    }

    // ===========================================
    // ===== CSV生成とダウンロード =====
    // ===========================================
    function generateCSVData() {
        if (appState.startTime === 0) return;

        // 1. 全脈波データを解析して、全ピーク情報を取得
        const samplingRate = 1000 / ((pulseState.rawTimestamps[pulseState.rawTimestamps.length - 1] - pulseState.rawTimestamps[0]) / (pulseState.rawTimestamps.length - 1));
        const invertedSignal = pulseState.rawBrightness.map(v => 255 - v);
        const filteredSignal = applyBandpassFilter(invertedSignal, samplingRate);
        const allPeaksInfo = findPeaksWithProminence(filteredSignal, pulseState.rawTimestamps, samplingRate);

        // 2. ピーク情報をタイムスタンプをキーにしたマップに変換
        const peakMap = new Map();
        const allPeakTimestamps = [];
        if (allPeaksInfo.length > 1) {
            for (let i = 0; i < allPeaksInfo.length; i++) {
                const peak = allPeaksInfo[i];
                allPeakTimestamps.push(peak.timestamp);
                let rri = 0, instantBpm = 0, averageBpm = 0;
                if (i > 0) {
                    rri = peak.timestamp - allPeaksInfo[i-1].timestamp;
                    instantBpm = 60000 / rri;
                }
                const recentPeaks = allPeaksInfo.slice(Math.max(0, i - 10), i + 1).map(p => p.timestamp);
                if (recentPeaks.length > 1) {
                    const totalInterval = recentPeaks[recentPeaks.length - 1] - recentPeaks[0];
                    averageBpm = 60000 / (totalInterval / (recentPeaks.length - 1));
                }
                peakMap.set(peak.timestamp, { rri, instantBpm, averageBpm });
            }
        }
        
        // 3. タップ情報をタイムスタンプをキーにしたマップに変換
        const tapMap = new Map();
        if (tapState.taps.length > 1) {
            for (let i = 0; i < tapState.taps.length; i++) {
                let currentBpm = 0, averageBpm = 0;
                if (i > 0) {
                    currentBpm = 60000 / (tapState.taps[i] - tapState.taps[i-1]);
                }
                const recentTaps = tapState.taps.slice(Math.max(0, i - 10), i + 1);
                if (recentTaps.length > 1) {
                     const totalInterval = recentTaps[recentTaps.length - 1] - recentTaps[0];
                    averageBpm = 60000 / (totalInterval / (recentTaps.length - 1));
                }
                tapMap.set(tapState.taps[i], { currentBpm, averageBpm });
            }
        }

        // 4. 0.01秒間隔でタイムラインを生成し、データをマージ
        const finalCsvData = [['Time_sec', 'RawBrightness', 'Pulse_Event', 'RRI_sec', 'Pulse_MomentBPM', 'Pulse_AverageBPM', 'Tap_Event', 'Tap_MomentBPM', 'Tap_AverageBPM', 'Name']];
        const duration = pulseState.rawTimestamps[pulseState.rawTimestamps.length - 1] - appState.startTime;
        let pIndex = 0; // pulse raw data index
        let peakIndex = 0;
        let tapIndex = 0;

        for (let t = 0; t <= duration; t += 10) {
            const currentTimestamp = appState.startTime + t;
            
            // Find corresponding raw brightness
            while(pIndex < pulseState.rawTimestamps.length - 1 && pulseState.rawTimestamps[pIndex] < currentTimestamp) {
                pIndex++;
            }
            const brightness = 255 - (pulseState.rawBrightness[pIndex] || 0);

            let pulseEvent = 0, rri = 0, pulseInstant = 0, pulseAvg = 0;
            if (peakIndex < allPeakTimestamps.length && currentTimestamp >= allPeakTimestamps[peakIndex]) {
                const peakTime = allPeakTimestamps[peakIndex];
                const data = peakMap.get(peakTime);
                pulseEvent = 1;
                rri = data.rri;
                pulseInstant = data.instantBpm;
                pulseAvg = data.averageBpm;
                peakIndex++;
            }

            let tapEvent = 0, tapCurrent = 0, tapAvg = 0;
             if (tapIndex < tapState.taps.length && currentTimestamp >= tapState.taps[tapIndex]) {
                const tapTime = tapState.taps[tapIndex];
                const data = tapMap.get(tapTime);
                tapEvent = 1;
                tapCurrent = data.currentBpm;
                tapAvg = data.averageBpm;
                tapIndex++;
            }

            finalCsvData.push([
                (t/1000).toFixed(2),
                brightness.toFixed(4),
                pulseEvent,
                (rri/1000).toFixed(3),
                pulseInstant.toFixed(1),
                pulseAvg.toFixed(1),
                tapEvent,
                tapCurrent.toFixed(1),
                tapAvg.toFixed(1),
                appState.userName
            ]);
        }
        appState.csvData = finalCsvData;
        showStatus("CSVデータの生成が完了しました。", false);
    }


    function downloadCombinedCSV() {
        if (appState.csvData.length <= 1) {
            showMessage("保存するデータがありません。", 3000);
            return;
        };
        const filename = `combined_data_${appState.userName}_${new Date().toISOString().slice(0,19).replace(/[-:T]/g,"")}.csv`;
        const csvContent = appState.csvData.map(e => e.join(",")).join("\n");
        downloadFile(filename, csvContent);
    }
    
    function showMessage(message, duration = 3000) {
        messageBox.textContent = message;
        messageBox.classList.remove('hidden');
        setTimeout(() => { messageBox.classList.remove('opacity-0'); }, 10);
        setTimeout(() => {
            messageBox.classList.add('opacity-0');
            setTimeout(() => messageBox.classList.add('hidden'), 300);
        }, duration);
    }
    
    function downloadFile(filename, content) {
        const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
        const blob = new Blob([bom, content], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        link.setAttribute("href", URL.createObjectURL(blob));
        link.setAttribute("download", filename);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    // --- 初期化 ---
    initializeAll();
    updateMainUI(false);

    </script>
</body>
</html>
